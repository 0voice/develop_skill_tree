# 常用算法

## 目录
* [排序、查找算法](https://github.com/0voice/develop_skill_tree/blob/main/common_skills_tree/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95.md#排序查找算法)
  * [选择排序](https://github.com/0voice/develop_skill_tree/blob/main/common_skills_tree/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95.md#选择排序)
  * [冒泡排序](https://github.com/0voice/develop_skill_tree/blob/main/common_skills_tree/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95.md#冒泡排序)
  * [插入排序](https://github.com/0voice/develop_skill_tree/blob/main/common_skills_tree/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95.md#插入排序)
  * [快速排序](https://github.com/0voice/develop_skill_tree/blob/main/common_skills_tree/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95.md#快速排序)
  * [归并排序](https://github.com/0voice/develop_skill_tree/blob/main/common_skills_tree/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95.md#归并排序)
  * [希尔排序](https://github.com/0voice/develop_skill_tree/blob/main/common_skills_tree/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95.md#希尔排序)
  * [堆排序](https://github.com/0voice/develop_skill_tree/blob/main/common_skills_tree/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95.md#堆排序)
  * [计数排序](https://github.com/0voice/develop_skill_tree/blob/main/common_skills_tree/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95.md#计数排序)
  * [桶排序](https://github.com/0voice/develop_skill_tree/blob/main/common_skills_tree/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95.md#桶排序)
  * [基数排序](https://github.com/0voice/develop_skill_tree/blob/main/common_skills_tree/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95.md#基数排序)
  * [二分查找](https://github.com/0voice/develop_skill_tree/blob/main/common_skills_tree/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95.md#二分查找)
  * [Java 中的排序工具](https://github.com/0voice/develop_skill_tree/blob/main/common_skills_tree/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95.md#java-中的排序工具)
* [布隆过滤器](https://github.com/0voice/develop_skill_tree/blob/main/common_skills_tree/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95.md#布隆过滤器)
* [字符串比较](https://github.com/0voice/develop_skill_tree/blob/main/common_skills_tree/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95.md#字符串比较)
  * [KMP 算法](https://github.com/0voice/develop_skill_tree/blob/main/common_skills_tree/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95.md#kmp-算法)
* [深度优先、广度优先](https://github.com/0voice/develop_skill_tree/blob/main/common_skills_tree/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95.md#深度优先广度优先)
* [贪心算法](https://github.com/0voice/develop_skill_tree/blob/main/common_skills_tree/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95.md#贪心算法)
* [回溯算法](https://github.com/0voice/develop_skill_tree/blob/main/common_skills_tree/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95.md#回溯算法)
* [剪枝算法](https://github.com/0voice/develop_skill_tree/blob/main/common_skills_tree/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95.md#剪枝算法)
* [动态规划](https://github.com/0voice/develop_skill_tree/blob/main/common_skills_tree/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95.md#动态规划)
* [朴素贝叶斯](https://github.com/0voice/develop_skill_tree/blob/main/common_skills_tree/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95.md#朴素贝叶斯)
* [推荐算法](https://github.com/0voice/develop_skill_tree/blob/main/common_skills_tree/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95.md#推荐算法)
* [最小生成树算法](https://github.com/0voice/develop_skill_tree/blob/main/common_skills_tree/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95.md#最小生成树算法)
* [最短路径算法](https://github.com/0voice/develop_skill_tree/blob/main/common_skills_tree/%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95.md#最短路径算法)

<br />
<br />
<br />
<br />
<br />

## 内容

### 常用算法

* [《常见排序算法及对应的时间复杂度和空间复杂度》](https://blog.csdn.net/gane_cheng/article/details/52652705)

##### 排序、查找算法

* [《常见排序算法及对应的时间复杂度和空间复杂度》](https://blog.csdn.net/gane_cheng/article/details/52652705)

##### 选择排序

* [《Java中的经典算法之选择排序（SelectionSort）》](https://www.cnblogs.com/shen-hua/p/5424059.html)
	* 每一趟从待排序的记录中选出最小的元素，顺序放在已排好序的序列最后，直到全部记录排序完毕。

##### 冒泡排序

* [《冒泡排序的2种写法》](https://blog.csdn.net/shuaizai88/article/details/73250615)
	* 相邻元素前后交换、把最大的排到最后。
	* 时间复杂度 O(n²) 

##### 插入排序

* [《排序算法总结之插入排序》](https://www.cnblogs.com/hapjin/p/5517667.html)

##### 快速排序

* [《坐在马桶上看算法：快速排序》](https://blog.csdn.net/afjaklsdflka/article/details/52829030)
	* 一侧比另外一侧都大或小。 
##### 归并排序

* [《图解排序算法(四)之归并排序》](http://www.cnblogs.com/chengxiao/p/6194356.html)
	* 分而治之，分成小份排序，在合并(重建一个新空间进行复制)。 

##### 希尔排序
TODO

##### 堆排序
* [《图解排序算法(三)之堆排序》](https://www.cnblogs.com/chengxiao/p/6129630.html)
	* 排序过程就是构建最大堆的过程，最大堆：每个结点的值都大于或等于其左右孩子结点的值，堆顶元素是最大值。

##### 计数排序
* [《计数排序和桶排序》](https://www.cnblogs.com/suvllian/p/5495780.html)
	* 和桶排序过程比较像，差别在于桶的数量。

##### 桶排序
* [《【啊哈！算法】最快最简单的排序——桶排序》](http://blog.51cto.com/ahalei/1362789)
* [《排序算法（三）：计数排序与桶排序》](https://blog.csdn.net/sunjinshengli/article/details/70738527)
	* 桶排序将[0,1)区间划分为n个相同的大小的子区间，这些子区间被称为桶。
	* 每个桶单独进行排序，然后再遍历每个桶。

##### 基数排序

按照个位、十位、百位、...依次来排。

* [《排序算法系列：基数排序》](https://blog.csdn.net/lemon_tree12138/article/details/51695211)
* [《基数排序》](https://www.cnblogs.com/skywang12345/p/3603669.html)


##### 二分查找
* [《二分查找(java实现)》](https://www.cnblogs.com/coderising/p/5708632.html)
	* 要求待查找的序列有序。
	* 时间复杂度 O(logN)。

* [《java实现二分查找-两种方式》](https://blog.csdn.net/maoyuanming0806/article/details/78176957)
	* while + 递归。
##### Java 中的排序工具
* [《Arrays.sort和Collections.sort实现原理解析》](https://blog.csdn.net/u011410529/article/details/56668545?locationnum=6&fps=1)
	* Collections.sort算法调用的是合并排序。
	* Arrays.sort() 采用了2种排序算法 -- 基本类型数据使用快速排序法，对象数组使用归并排序。

##### 布隆过滤器

常用于大数据的排重，比如email，url 等。
核心原理：将每条数据通过计算产生一个指纹（一个字节或多个字节，但一定比原始数据要少很多），其中每一位都是通过随机计算获得，在将指纹映射到一个大的按位存储的空间中。注意：会有一定的错误率。
优点：空间和时间效率都很高。
缺点：随着存入的元素数量增加，误算率随之增加。

* [《布隆过滤器 -- 空间效率很高的数据结构》](https://segmentfault.com/a/1190000002729689)
* [《大量数据去重：Bitmap和布隆过滤器(Bloom Filter)》](https://blog.csdn.net/zdxiq000/article/details/57626464)
* [《基于Redis的布隆过滤器的实现》](https://blog.csdn.net/qq_30242609/article/details/71024458)
	* 基于 Redis 的 Bitmap 数据结构。
* [《网络爬虫：URL去重策略之布隆过滤器(BloomFilter)的使用》](https://blog.csdn.net/lemon_tree12138/article/details/47973715)
	* 使用Java中的 BitSet 类 和 加权和hash算法。

##### 字符串比较

##### KMP 算法
KMP：Knuth-Morris-Pratt算法（简称KMP）
核心原理是利用一个“部分匹配表”，跳过已经匹配过的元素。
* [《字符串匹配的KMP算法》](http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html)

##### 深度优先、广度优先
* [《广度优先搜索BFS和深度优先搜索DFS》](https://www.cnblogs.com/0kk470/p/7555033.html)

##### 贪心算法
* [《算法：贪婪算法基础》](https://www.cnblogs.com/MrSaver/p/8641971.html)
* [《常见算法及问题场景——贪心算法》](https://blog.csdn.net/a345017062/article/details/52443781)

##### 回溯算法
* [《 五大常用算法之四：回溯法》](https://blog.csdn.net/qfikh/article/details/51960331)

##### 剪枝算法
* [《α-β剪枝算法》](https://blog.csdn.net/luningcsdn/article/details/50930276)

##### 动态规划
* [《详解动态规划——邹博讲动态规划》](https://www.cnblogs.com/little-YTMM/p/5372680.html)
* [《动态规划算法的个人理解》](https://blog.csdn.net/yao_zi_jie/article/details/54580283)

##### 朴素贝叶斯

* [《带你搞懂朴素贝叶斯分类算法》](https://blog.csdn.net/amds123/article/details/70173402)
	* P(B|A)=P(A|B)P(B)/P(A)

* [《贝叶斯推断及其互联网应用1》](http://www.ruanyifeng.com/blog/2011/08/bayesian_inference_part_one.html)
* [《贝叶斯推断及其互联网应用2》](http://www.ruanyifeng.com/blog/2011/08/bayesian_inference_part_two.html)


##### 推荐算法
* [《推荐算法综述》](http://www.infoq.com/cn/articles/recommendation-algorithm-overview-part01)
* [《TOP 10 开源的推荐系统简介》](https://www.oschina.net/news/51297/top-10-open-source-recommendation-systems)

##### 最小生成树算法
* [《算法导论--最小生成树（Kruskal和Prim算法）》](https://blog.csdn.net/luoshixian099/article/details/51908175)

##### 最短路径算法

* [《Dijkstra算法详解》](https://blog.csdn.net/qq_35644234/article/details/60870719)
